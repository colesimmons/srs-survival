"""
This file cleans up the raw export generated by using the following Anki add-on:
https://ankiweb.net/shared/info/1806723271

Problems with the raw export:
- Each row of the raw export has 2 reviews, and the columns for each are in different orders.
- The second review of a row is be the first review of the another.
- The plugin does not support exporting by deck, but instead exports all reviews for all decks.

What this script does:
- Puts each review on its own row
- Ensures no duplicates
- Optional: limit reviews to a specific deck

Input columns:
- Date1|Answer1|Interval|Ease factor|Time to answer1|Review type1|Date2|Answer2|Time to answer2|Review type2|Card ID

Output columns:
- card_id | timestamp | was_remembered | answer_score | secs_to_answer | is_review

Column details:
- card_id {int} -- unique card ID, also the epoch milliseconds of when the card was created
- timestamp {str} -- timestamp of when the review was performed, e.g. "2022-11-17 07:29:26"
- was_remembered {int} -- 1 if the card was remembered (answer_score > 1), 0 otherwise
- answer_score {int} -- user's self-assessed recall performance rating; 1 (wrong), 2 (hard), 3 (ok), or 4 (easy)
- secs_to_answer {float} -- the time it took to answer the card in seconds
- review_type {string} -- 'Learn', 'Review', or 'Relearn'
    Anki does not start scheduling cards until they have been "learned" (successfully answered as 3 twice consecutively)
    If the card is forgotten, it must be "relearned" (successfully answered same day) before being scheduled again

See note at bottom for additional fields that can be extracted for Anki entities
"""


import csv
from anki_export import ApkgReader
from datetime import datetime


input_file = 'anki_export.csv'
output_file = 'review_history.csv'
anki_file = 'decks.apkg'
deck_name_contains = 'Archive'  # str that must be present in the deck name, or None


def main():
  with open(input_file, 'r') as csvfile:
    reader = csv.reader(csvfile)
    next(reader)  # skip header

    # -------------------------
    # 1. fetch addl data from anki file
    # -------------------------
    reviews = {}
    with ApkgReader(anki_file) as apkg:
      for row in reader:
        try:
          rev_1_at, rev_1_answer, _, _, rev_1_tt_answer, rev_1_type, rev_2_at, rev_2_answer, rev_2_tt_answer, rev_2_type, card_id = row
          card_info = apkg.find_card_by_id(card_id)
        except Exception as e:
          continue

        # Filter out cards if necessary
        deck_name = card_info["data"]["deck"]["name"]
        if deck_name_contains and deck_name_contains not in deck_name:
          continue

        # Add data for each review
        # This is added to a dict, keyed by timestamp, to ensure no duplicates
        reviews[rev_1_at] = {
            "card_id": int(card_id),
            "timestamp": datetime.strptime(rev_1_at, "%Y-%m-%d %H:%M:%S"),
            "answer": int(rev_1_answer),
            "secs_to_answer": float(rev_1_tt_answer),
            "review_type": rev_1_type,
        }

        reviews[rev_2_at] = {
            "card_id": int(card_id),
            "timestamp": datetime.strptime(rev_2_at, "%Y-%m-%d %H:%M:%S"),
            "answer": int(rev_2_answer),
            "secs_to_answer": float(rev_2_tt_answer),
            "review_type": rev_2_type,
        }

    # -------------------------
    # 2. write output
    # -------------------------
    with open(output_file, 'w', newline='') as csvfile:
      writer = csv.writer(csvfile)

      # Write output headers
      headers = ['card_id', 'timestamp', 'was_remembered',
                 'answer_score', 'secs_to_answer', 'review_type']
      writer.writerow(headers)

      # Sort by card_id -> timestamp
      reviews_sorted = sorted(
          reviews.values(),
          key=lambda r: (r['card_id'], r['timestamp'])
      )

      for review in reviews_sorted:
        card_id = review["card_id"]
        timestamp = review["timestamp"]
        secs_to_answer = review["secs_to_answer"]
        answer_score = review["answer"]
        review_type = review["review_type"]
        was_remembered = int(answer_score > 1)
        if review_type == 'Resched':
          continue

        # write review
        row = [card_id, timestamp, was_remembered,
               answer_score, secs_to_answer, review_type]
        writer.writerow(row)


main()

# for future reference, a mostly-comprehensive list of other fields available on Anki entities.
# retrieved from https://github.com/ankidroid/Anki-Android/wiki/Database-Structure

# ----------------- CARD -----------------
# ord : identifies which of the card templates or cloze deletions it corresponds to
#   for card templates, valid values are from 0 to num templates - 1
#   for cloze deletions, valid values are from 0 to max cloze index - 1 (they're 0 indexed despite the first being called `c1`)
#  mod : the epoch milliseconds of when the card was last modified
#  usn : update sequence number : used to figure out diffs when syncing.
#  type : 0=new, 1=learning, 2=review, 3=relearning
#  queue : int from -3 - 4 (suspended, user buried, sched buried, user buried, new, learning, review)
#  due : due is used differently for different card types, but used to find next time card is due
#  ivl : interval (used in SRS algorithm). Negative = seconds, positive = days
#  factor : The ease factor of the card in permille (parts per thousand). If the ease factor is 2500, the cardâ€™s interval will be multiplied by 2.5 the next time you press Good.
#  reps : # of reviews
#  lapses : the number of times the card went from a "was answered correctly" to "was answered incorrectly" state
#  left : the number of reviews left before the card graduates from learning
#  odue : original due: only used when the card is currently in filtered deck
#  odid : original did: only used when the card is currently in filtered deck
#  flags : an integer. This integer mod 8 represents a "flag", which can be see in browser and while reviewing a note. Red 1, Orange 2, Green 3, Blue 4, no flag: 0. This integer divided by 8 represents currently nothing
#  data["deck"] - deck info


# ----------------- NOTE -----------------
# mid : model id
# flds : the values of the fields in this note. separated by 0x1f (31) character.
#   guid : used for syncing
#   mod : modification timestamp
#   usn : updated sequence number : used to figure out diffs when syncing.
#   tags : space-separated string of tags. includes space at the beginning and end, for LIKE "% tag %" queries.
#   sfld : sort field: used for quick sorting and duplicate check.
#       The sort field is an integer so that when users are sorting on a field that contains only numbers, they are sorted in numeric instead of lexical order.
#       Text is stored in this integer field.
#   csum : field checksum used for duplicate check.
#   flags : unused
#   data : unused


# ----------------- MODEL -----------------
# css : CSS, shared for all templates
# did : Long specifying the id of the deck that cards are added to by default
# flds : JSONArray containing object for each field in the model as follows:
#   eg. [{
#       font : "display font",
#       media : "array of media. appears to be unused",
#       name : "field name",
#       ord : "ordinal of the field - goes from 0 to num fields -1",
#       rtl : "boolean, right-to-left script",
#       size : "font size",
#       sticky : "sticky fields retain the value that was last added when adding new notes"
#   }]
# id : model ID, matches notes.mid
# latexPost : String added to end of LaTeX expressions (usually \\end{document})"
# latexPre : preamble for LaTeX expressions
# mod : modification time in seconds
# name : model name
# req : unused in modern clients. May exist for backwards compatibility.
# sortf : Integer specifying which field is used for sorting in the browser
# tags : Anki saves the tags of the last added note to the current model, use an empty array []
# tmpls : JSONArray containing object of CardTemplate for each card in model
#   eg. [{
#       afmt : answer template string,
#       bafmt : browser answer format: used for displaying answer in browser,
#       bqfmt : browser question format: used for displaying question in browser,
#       did : deck override (null by default),
#       name : template name,
#       ord : template number, see flds,
#       qfmt : question format string
#   }]
# type : Integer specifying what type of model. 0 for standard, 1 for cloze
# usn : Update sequence number: used in same way as other usn vales in db
# vers : Legacy version number (unused), use an empty array []
